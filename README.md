
<div align="center">
	
![로고이미지](https://raw.githubusercontent.com/cafeLogProject/README/main/image/brewscape.png)

</div>


# ☕ Brewscape - 카페로그

### "공부하기 좋은 카페 없나? 커피가 맛있는 카페 없나?"

## 💡 서비스 소개

카페로그는 카페를 탐색하고 리뷰하며, 나만의 기록을 남기고 다른 사용자들과 공유할 수 있는 웹 서비스입니다.

#### 카페로그는 이런 분들을 위한 서비스입니다
* 📚 공부나 작업을 위한 조용한 카페를 찾고 계신 분
* ☕ 커피 맛이 특별하고 자체 로스팅한 원두를 판매하는 카페를 찾는 미각의 소유자
* 🎨 개성있고 분위기 있는 인테리어의 카페를 선호하는 분
* 📝 나만의 카페 탐방 기록을 남기고 싶은 카페 매니아
* 🤝 같은 취향을 가진 사용자들과 소통하고 싶은 분

## ✨ 주요 기능

### 🔍 카페 검색 및 정보
* 네이버 지도 API를 활용한 실시간 카페 검색으로 실제 존재하는 카페만 찾아볼 수 있어요
* 카페 상세 정보로 분위기와 특성을 한눈에 파악할 수 있어요
* 원하는 카페를 스크랩하여 나중에 쉽게 찾아볼 수 있어요

### 📝 리뷰 작성 및 관리
* 방문한 카페에 대한 별점과 상세 리뷰를 작성할 수 있어요
* 카페의 특징을 태그로 분류하여 더 정확한 정보를 공유할 수 있어요
* 작성 중인 리뷰는 자동으로 임시저장되어 언제든 이어서 작성 가능해요
* 카페의 분위기와 메뉴를 사진으로 기록하고 공유할 수 있어요

### 🧭 리뷰 탐색
* 최신순/별점순으로 리뷰를 정렬하여 원하는 방식으로 탐색할 수 있어요
* 공부, 맛, 인테리어 등 다양한 태그로 필터링하여 취향에 맞는 카페를 찾을 수 있어요
* 커서 기반 무한 스크롤로 더 많은 리뷰를 끊김 없이 살펴볼 수 있어요
* 이미지 뷰어로 카페 사진을 더 자세히 살펴보고 좌우 네비게이션으로 쉽게 이동할 수 있어요

### 👥 소셜 기능
* 다른 사용자를 닉네임으로 검색하고 프로필을 확인할 수 있어요
* 팔로우/언팔로우 기능으로 관심 있는 사용자의 리뷰를 쉽게 모아볼 수 있어요
* 팔로워/팔로잉 목록을 확인하고 관리할 수 있어요
* 프로필 이미지 설정과 소개 편집으로 나만의 개성을 표현할 수 있어요

### 🚀 사용자 경험
* 소셜 로그인(Google, Facebook, Naver)으로 간편하게 서비스를 시작할 수 있어요
* 토스트 알림으로 주요 작업의 성공/실패 여부를 바로 확인할 수 있어요
* 로딩 스피너, 모달 등 다양한 UI 요소로 직관적인 알림을 제공해요

<br>

## 📅 개발 기간
#### `2024.12.13 ~ 2025.2.28 (3개월)
<br>

## 🏃 팀원 소개
<table>
  <tr>
    <td align="center"><a href="https://github.com/acoldbottle">김병찬</a></td>
    <td align="center"><a href="https://github.com/moonnamkyung">문남경</td>
    <td align="center"><a href="https://github.com/florence1920">이승헌</a></td>
    <td align="center"><a href="https://github.com/rough78">임용태</a></td>
    <td align="center"><a href="https://github.com/leejuyeon-star">이주연</a></td>
  </tr>
  <tr>
    <td align="center">Backend</td>
    <td align="center">UI/UX Design</td>
    <td align="center">Frontend</td>
    <td align="center">Frontend</td>
    <td align="center">Backend</td>
  </tr>
  <tr>
    <td align="center">kimbc715@gmail.com</td>
    <td align="center">luna7252@naver.com</td>
    <td align="center">jetaime21212@gmail.com</td>
    <td align="center">lim7897@gmail.com</td>
    <td align="center">kkobucks@naver.com</td>
  </tr>
  <tr>
    <td align="center">
	<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/byoungchan.png" alt="chan" width="100">    
    </td>
    <td align="center">
	    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/moon.png" alt="moon" width="100">    
    </td>
    <td align="center">
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/leeseungheon.jpg" width="100" alt="lsh"/>  
    </td>
    <td align="center">
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/refs/heads/main/image/profile/limyongtae.jpg" width="100" alt="yongtae"/>  
    </td>
    <td align="center">
      <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/leejuyeon.jpg" alt="juyeon" width="100">
    </td>
  </tr>
</table>

<br>

## 🔍 주요 기능

<table>
  <tr>
    <td align="center"><strong>카페 검색 + 카페 정보</strong></td>
    <td align="center"><strong>카페 스크랩</strong></td> 
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/4dfa7ed6-92c9-4ecc-875a-e694555c6577" alt="카페 검색 + 카페 정보" width="40%">
    </td>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/1cc60b08-5b6f-4a3a-a2af-57c60e37c2d8" alt="카페 스크랩" width="40%">
    </td>
  </tr>	
  <tr>
    <td align="center"><strong>리뷰 무한스크롤</strong></td>
    <td align="center"><strong>팔로우한 유저의 리뷰 조회</strong></td> 
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/954ebea0-5dc1-49fc-9916-4857acc714aa" alt="리뷰 무한스크롤" width="40%">
    </td>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/faca1ec6-175a-440f-8678-e83b1c70d724" alt="팔로우한 유저의 리뷰 조회" width="40%">
    </td>
  </tr>	
  <tr>
    <td align="center"><strong>리뷰 필터링 조회</strong></td>
    <td align="center"><strong>리뷰 작성</strong></td> 
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/d3b4645e-cfab-44a8-b78a-fc5187059ae5" alt="리뷰 필터링 조회" width="40%">
    </td>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/36fccb43-77e3-411b-87c6-b6b02e6a7620" alt="리뷰 작성" width="40%">
    </td>
  </tr>
  <tr>
    <td align="center"><strong>리뷰 임시저장</strong></td>
    <td align="center"><strong>마이페이지 + 팔로잉,팔로워 조회</strong></td> 
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/3653c5da-6d0b-4fae-8885-fbb200b7441e" alt="리뷰 임시저장" width="40%">
    </td>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/12df0b88-d300-4ee9-abf1-6a8b5588203a" alt="마이페이지 + 팔로잉,팔로워 조회" width="40%">
    </td>
  </tr>
  <tr>
    <td align="center"><strong>유저 검색 + 유저페이지 + 팔로우, 언팔로우</strong></td>
    <td align="center"><strong>프로필 수정</strong></td> 
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/2e037f1f-05f9-4fc5-9fae-523d08a2c0ad" alt="유저 검색 + 유저페이지 + 팔로우, 언팔로우" width="40%">
    </td>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/c2ab8044-1157-49d8-9186-9849aba8505c" alt="프로필 수정" width="40%">
    </td>
  </tr>
  <tr>
    <td align="center"><strong>회원가입, 로그인</strong></td>
  </tr>	
  <tr>
    <td align="center">
      <img src="https://github.com/user-attachments/assets/b6f974fe-5bf9-4e38-b52c-ff7066b5b85f" alt="회원가입, 로그인" width="40%">
    </td>
  </tr>
</table>
<br>

<br>




## 📚 기술 스택

<h3>프론트엔드</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/react.svg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/typescript.svg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/vite.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/reactquery.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/zustand.jpg" width="100"></td>
  </tr>
  <tr>
    <td>React</td>
    <td>TypeScript</td>
    <td>Vite</td>
    <td>React Query</td>
    <td>Zustand</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/scss.png" width="100"></td>
  </tr>
  <tr>
    <td>SCSS</td>
  </tr>
</table>


<h3>백엔드</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/java.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/gradle.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/spring_boot.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/oauth2.jpeg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/ss.png" width="100"></td>
  </tr>
  <tr>
    <td>Java 21</td>
    <td>Gradle</td>
    <td>Spring Boot</td>
    <td>Oauth2</td>
    <td>Spring Security</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jpa.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/queryDsl.jpg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/redis.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/mysql.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/elasticache.png" width="100"></td>
  </tr>
  <tr>
    <td>Spring Data JPA</td>
    <td>QueryDSL</td>
    <td>Redis</td>
    <td>MySQL 8</td>
    <td>ElastiCache</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/mockito.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/junit.png" width="100"></td>
  </tr>
  <tr>
    <td>Mockito</td>
    <td>Junit 5</td>
  </tr>
</table>

<h3>DevOps</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/actions.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/docker.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/ec2.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/rds.png" width="100"></td>
  </tr>
  <tr>
    <td>Github Actions</td>
    <td>Docker</td>
    <td>AWS EC2</td>
    <td>AWS RDS</td>
  </tr>
</table>

<h3>협업툴</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/github.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/notion.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/figma.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/discord.png" width="100"></td>
  </tr>
  <tr>
    <td>Github</td>
    <td>Notion</td>
    <td>Figma</td>
    <td>Discord</td>
  </tr>
</table>


<br>

## 💻 주요 개발 내용

### 프론트엔드
- **검색 기능 개발**: 카페 및 사용자 검색 기능 구현
- **리뷰 기능 구현**: 리뷰 작성, 수정, 삭제, 임시저장 기능 개발
- **인증 관리**: Protected Route 설정, 사용자 인증 및 권한 관리
- **이미지 관리**: UI와 동기화된 미리보기 이미지 업로드, 네비게이션 기능이 있는 뷰어 컴포넌트 개발
- **무한 스크롤**: 리뷰 목록, 팔로우 리스트 등에 커서 기반 무한 스크롤 구현
- **소셜 기능**: 팔로워/팔로잉 페이지, 프로필 검색, 팔로우/언팔로우 기능 구현
- **상태 관리**: Zustand를 활용한 전역 상태 관리, React Query를 활용한 서버 상태 관리
- **UI/UX 개선**: 로딩 스피너, 토스트 알림, 모달, 빈 데이터 표시 등 UI 컴포넌트 개발 및 스타일 최적화

### 백엔드
- **인증 시스템**: OAuth2를 활용한 소셜 로그인(구글, 페이스북, 네이버) 구현
- **프로필 관리**: 사용자 정보 조회 및 수정, 닉네임 중복 체크 기능 개발
- **카페 API**: 네이버 검색 API를 활용한 카페 검색 및 저장 기능 개발
- **리뷰 API**: 리뷰 CRUD, 태그 기반 필터링, 정렬 기능 구현
- **소셜 기능**: 팔로우/언팔로우, 팔로워/팔로잉 목록 조회 기능 개발
- **이미지 처리**: 리뷰 이미지, 프로필 이미지, 등록, 리사이즈 및 압축 개발
- **보안**: JWT 토큰 기반 인증/인가 시스템 구현
- **데이터 접근**: JPA와 QueryDSL을 활용한 효율적인 데이터 접근 계층 구현

<br>

## 🧩 핵심 기술 요소

### 커서 기반 무한 스크롤
팔로워/팔로잉 리스트, 리뷰 목록 등에 useInfiniteQuery를 활용한 커서 기반 무한 스크롤을 구현하여 사용자 경험을 개선했습니다. 탭 전환 시 데이터 초기화 및 스크롤 위치 관리를 통해 자연스러운 UX를 제공합니다.

### 프로필 검색 및 팔로우 시스템
닉네임 기반으로 사용자를 검색하고, 팔로우/언팔로우할 수 있는 기능을 구현했습니다. 팔로잉 중인 사용자의 리뷰만 모아볼 수 있는 전용 탭을 제공하여 소셜 기능을 강화했습니다.

### 리뷰 임시저장 시스템
리뷰 작성 중 페이지를 이탈하더라도 자동으로 임시저장되어 나중에 이어서 작성할 수 있는 기능을 개발했습니다. 백엔드와의 실시간 연동으로 데이터 손실을 방지하고, 임시저장된 리뷰 목록을 관리할 수 있습니다.

### 이미지 관리 시스템
사용자가 업로드한 이미지들을 압축하여 저장하고, 조회시 등록순으로 정렬하여 표시하는 기능을 구현했습니다.

### 토스트 알림 시스템
API 요청 성공/실패 시 사용자에게 직관적인 피드백을 제공하는 토스트 알림 시스템을 구현하여 사용자 경험을 향상시켰습니다.

### Suspense와 ErrorBoundary를 활용한 로딩/에러 처리
React의 Suspense와 ErrorBoundary를 활용하여 로딩 및 에러 상태를 효과적으로 관리했습니다. 로딩 중에는 스피너를, 데이터가 없는 경우에는 맞춤형 대체 화면을 표시하여 사용자 경험을 개선했습니다.

### 리뷰 필터링 조회
리뷰를 태그로 필터링하고 최신순/별점순으로 정렬하여 조회하는 기능을 구현했습니다.


## 🌟 주요 기능 구현
- [이주연]
  	- 리뷰 관련 기능
  	  	- QueryDsl를 사용한 조회 구현
  	   		- 리뷰 최신순/별점순 조회
			- 리뷰 태그 필터링 조회
  	  		- 카페의 모든 리뷰 조회
  	   		- 내 모든 리뷰 조회
		- 리뷰 CRUD
  	- 리뷰 임시저장 관련 기능
  	  	- 내 임시저장 조회
 		- 임시저장 CRUD
	- 이미지 관련 기능
   		- if-modified-since 헤더 이용한 이미지 캐싱 사용
 		- 리뷰 이미지 CRUD
		- 임시저장 리뷰 이미지 CRUD
		- 프로필 이미지 CRUD
	- 유저페이지 관련 기능
   	  	- useInfiniteQuery를 이용한 무한 스크롤 구현
   	- 로딩/에러 관련 기능
   	  	- Suspense를 이용한 로딩 처리
   	  	- ErrorBoundary를 이용한 공통 에러 페이지 처리
   	  	- useQuery를 사용하여 예측가능한 에러 토스트 처리


<br>

## ⚽ 트러블 슈팅

<details>
<summary> 이주연 </summary>
<details>
<summary>Collection 타입 조회/저장시 쿼리 다수 호출 문제 해결 (N+1 문제)</summary>
<br>

# 🤔문제 발생

- 한 엔티티에 일반 Collection타입(@ElementCollection) 필드값을 지정했을때, 저장/수정/조회시 쿼리가 다수 호출되는 문제 발생

- **조회 시**: 모든 Review엔티티의 tag 값을 조회할 때,  아래 쿼리가 **Review의 개수만큼** 반복 실행됨 → N+1 문제
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-1.png">
    

- **저장 시**: Review의 tag를 저장할 때, 아래 쿼리가 **tag의 개수만큼** 반복 실행됨
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-2.png">
    

# 🔍원인 분석

### 쿼리 분석

- 위의 쿼리를 보면 review_tags라는 테이블 때문에 저장/조회할때 쿼리가 많이 실행되는것을 알 수 있음
- review_tags 테이블은 자의로 생성한 기억이 없어서 어떤 이유로 생성되었는지 찾아보니, 아래 사진처럼 review 엔티티의 필드에 @CollectionTable로 지정되어 있었다.. 충분히 고민하지 않고 어노테이션을 적용하여 문제가 발생했던 것!
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-3.jpg">
    

### Collection의 매핑 테이블이 문제다!

- review_tags는 review와 tag간의 외래키를 저장하는 테이블임
    - **테이블이 왜 생겼을까?**
        - Collection 타입은 고유 식별자가 없기 때문에, 아래 사진처럼 부모 엔티티의 식별자를 매핑한 테이블(review_tags)이 생성됨
            
            <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-4.png">
            
    - 이로 인해, **Collection 타입을 저장할때마다 매핑 테이블에 식별자를 저장하는 쿼리가 실행되고, 조회할때마다 매핑테이블을 조회하는 쿼리가 실행됨 →** N+1 문제
    

# ⛏해결 과정

## 💡 **@ElementCollection 필드 조회시 N+1 문제 해결과정**

### ✅ 시도**1 : FetchType.EAGER로 변경하기**

- 기본적으로 @ElementCollection은 FetchType.LAZY로 작동하는데, 이를 EAGER로 변경하여 Collection값을 모두 로드한 후 조회
- 단점 : EAGER로 설정하면 부모 엔티티만 조회할 때도 자식인 Collection 값까지 같이 조회되므로 **N+1 문제가 발생**할 수 있음

### ✅ 시도**2 : fetch join 사용하기**

- EAGER 대신 LAZY + fetch join 조합 사용
- **단점** : QueryDSL을 사용할땐 @ElementCollection 필드의 Q객체를 자동으로 생성하지 않아join/fetch join을 사용할 수 없음 → 가독성을 위해 QueryDSL을 사용하여 구현해야 했으므로 보류

### ✅ 시도**3 : @ElementCollection 타입 대신 Embedded 타입 사용하기**

- 테이블을 따로 생성하지 않고 부모 엔티티 테이블 내에 데이터를 넣는 방식
    
    아래 사진처럼 리스트에 들어갈 모든 경우의 수를 저장해야 한다.
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-5.png">
    
- **장점** : 다른 방법보다 구현이 쉬움
- **단점** :
    - 리스트 값이 무엇인지 예측할 수 없으면 사용하기 어려움
    - 리스트값들을 변수로 바꾸는 것이기 때문에 리스트 값이 많을 경우 테이블 칼럼 수가 많아져 아래 사진처럼 보기 안좋음
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-6.png">
    

### ✅ 시도**4 : @ElementCollection 타입 대신 Entity 타입 사용하기**

- **장점** : join을 사용하여 N+1문제 해결 가능
- **단점** :
    - 방법3보다 구현 난이도 높음
    - 저장 쿼리에서 쿼리 과다문제가 발생하므로 batch insert를 사용해야 함



## 💡 **@ElementCollection 필드 저장시 쿼리 과다 문제 해결과정**

### ✅ 시도 : **batch insert 사용하기 → 실패**

- 적용해보았지만 작동하지 않음
    - 쿼리 로그를 통해 batch insert가 작동하지 않음을 확인
        
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-7.png">
        

        → 서칭해보니 Hibernate는 @ElementCollection에 대해 Batch insert가 작동하지 않는다고 함

참고링크 : [https://stackoverflow.com/questions/61102607/why-doesnt-hibernate-batch-inserts-of-fields-annotated-with-elementcollection](https://stackoverflow.com/questions/61102607/why-doesnt-hibernate-batch-inserts-of-fields-annotated-with-elementcollection)

## ❓**그럼 언제 @ElementCollection 타입을 사용하는게 좋은가?**

- @ElementCollection은 ****저장/수정/조회 모든 면에서 쿼리가 추가 발생하므로 가급적 사용하지 않는게 좋음
- 엔티티보다 간단한 구현이 필요할 때 사용
- 저장/수정/조회가 빈번하지 않은 배열값일 때 사용

# 💎결론

- @ElementCollection 필드를 사용할 경우 저장/수정/조회 면에서 쿼리가 다량 발생했다. 이를 해결하기 위해 Entity 타입이나 Embedded 타입을 사용해야 한다.
- 해당 프로젝트에서는 리스트 값이 많아 Entity 타입을 선택했고, join을 사용하여 N+1 문제를 해결했다.
</details>




<details>
<summary>고아 데이터 처리 문제 해결</summary>
<br>

# 🤔문제 발생

- 사용자가 **게시글에 이미지를 업로드한 후 작성 취소하면**, 이미지가 삭제되지 않고 서버에 남아버리는 문제 발생

# 🔍원인 분석

### **현재 상태**

- 사용자가 게시글을 작성하는 동안 **DB에는 게시글이 저장되지 않음**.
- **게시글 저장 API**와 **이미지 저장 API**가 **분리**되어 있음.
- 게시글을 삭제하면 **해당 게시글의 이미지도 함께 삭제됨**.

### **문제 발생 시나리오**

1. 사용자가 **게시글을 작성하면서 이미지 업로드**
2. **이미지가 먼저 서버에 저장됨**
3. 사용자가 **게시글 작성 취소**
4. 이미지가 삭제되지 않아 **고아 상태로 남음**

# ⛏해결 과정

## ❓**고아 이미지 문제를 어떻게 해결할까?**

### ✅ **방법 1: 고아 이미지를 주기적으로 삭제**

- **이미지 저장 시, 저장 시간을 함께 기록**
- 일정 기간이 지난 후, 게시글에 연결되지 않은 이미지를 **정기적으로 삭제**
- **단점**: 일정 간격으로 삭제 작업을 수행해야 함

### ✅ **방법 2: 게시글 임시저장 기능 추가**

- **새 게시글 작성시 바로 임시저장 게시글 저장**
- 이미지 저장 시, 임시저장 게시글과 연결
- **사용자가 작성 취소 시, 임시저장 게시글과 이미지를 함께 삭제**
- **장점**: 애초에 고아 이미지 발생 x

### 📌 결론

프로젝트 특성상 **임시저장 기능이 필요했기 때문에 방법 2로 결정!**



## ❓ **임시저장 게시글을 어떻게 저장할까?**

### **✅ 방법 1: 임시저장 전용 테이블을 따로 만들기**

- **장점**
    - 임시저장 데이터만 별도로 관리 가능
        
        → **주기적 삭제 기능 추가 시 구현이 쉽고 처리 속도 빠름**
        
- **단점**
    - 게시글을 공개로 전환할 때 **임시저장 테이블에서 공개 테이블로 이동해야함
    →** 이 과정에서 삭제 쿼리 + 생성 쿼리 발생 → **저장 속도 저하**

### **✅ 방법 2: 기존 게시글 테이블에 저장 & 임시저장 여부 필드 추가**

- **장점**
    - 임시저장 외에도 (삭제, 신고, 비공개 등) **다양한 상태 관리 가능**
- **단점**
    - 게시글을 검색할 때 **임시저장인지, 공개된 글인지 매번 필터링 필요**
    - 쿼리 실행 부담 증가 ****→ 조회 속도 저하

### 📌 결론

프로젝트 특성상 **검색/조회가 더 빈번**하므로, 저장/수정보다 조회 성능을 고려하여 **1번째 방법 채택!**



## **🛠구축 후 깨달은 방법 1의 문제점**

### **1️⃣ 개발 시간이 많이 걸림**

- 게시글과 연관된 엔티티가 있다면, **임시저장 게시글과도 연관된 엔티티를 새로 만들어야 함 →** 개발 난이도 증가
- 임시 해결책: 연관 엔티티를 컬렉션 자료형으로 변경
    → 저장/조회/수정 시 **추가적인 쿼리 발생, 결국 속도 저하**

### **2️⃣ 코드의 유연성이 떨어짐**

- 게시글 상태(삭제, 신고, 비공개 등)를 추가하려면 **별도 테이블을 계속 만들어야 함**
    
    → 결국 기존 테이블에 상태 필드를 추가하는 방향으로 가게 됨
    
    → 그럴바에 **임시저장 여부도 처음부터 상태 필드로 관리하는 게 더 낫다고 판단**
    

### 3️⃣ **조회 속도 저하 우려는 크지 않음**

- 사실 임시저장 여부를 확인하는 쿼리는 **대규모 데이터가 아니면 성능 문제 없음**

### 📌 결론

**다음번엔 방법 2를 사용하자!**

# 💎결론

- 임시저장 기능을 도입해 고아 이미지 문제를 해결했지만, 임시저장 전용 테이블 방식은 개발 복잡도와 유지보수 측면에서 비효율적이었다.
- 다음에는 기존 게시글 테이블에 상태 필드를 추가하는 방식으로 설계하여 유연성과 개발 효율성을 높이자!

</details>


<details>
<summary>태그 조회 문제 해결</summary>
<br>

# 🤔문제 발생

- **여러 개의 태그를 가진 게시물을 여러 개의 태그로 조회하는 API**를 제작해야 했다.
- **지정한 모든 태그를 포함한 게시물만 조회**해야 했다.
- IN 쿼리로 시도했지만 **태그 중 하나만 포함되어도 조회되는 문제 발생**
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds){
        return queryFactory
                        .from(review)
                        .where(tag.tagId.in(selectedTagIds))
                .fetch();
    }
    ```
    

# ⛏해결 과정

### ✅ 시도 1: groupBy + having 사용 → 실패

```java
public List<Review> tagSearch(List<Integer> selectedTagIds){
    return queryFactory
                    .from(review)
                    .where(tag.tagId.in(selectedTagIds))
                    .groupBy(review.id)
                    .having(tag.tagId.count().eq(selectedTagIds.size()))
            .fetch();
}
```

- 구현 실패
    - 일부 태그만 포함되더라도 **태그 개수만 맞으면 조회되는 문제**가 발생.
    
    → 지정한 모든 태그를 포함하는 게시물만 조회하는 ****조건을 만족하지 못함
    

### ✅ 시도 2: contains() 활용 → 실패

```java
public List<Review> tagSearch(List<Integer> selectedTagIds)
    return queryFactory
                    .from(review)
                    .where(review.tags.contains("tag1"))
                    .fetch();
}
```

- 구현 실패
    - contains()는 특정 1개의 태그 포함 여부만 확인 가능.
    - **태그 여러개 포함 여부는 확인 불가능**하여 조건을 만족하지 못함
    

### ✅ 시도 3: 태그 개수별 개별 조회 함수 작성 → 실패

- 1개 태그 조회, 2개 태그 조회... 태그 개수에 따른 조회하는 함수를 여러개 만드는 방법
- 문제점
    - **함수 개수가 태그 개수만큼 늘어나 좋지 않음**

### ✅ 시도 4: QueryDSL 동적 쿼리 활용 → 성공!

- 동적 쿼리를 이용하여 태그의 개수에 따라 태그 조회 조건이 변하는 단 한개의 함수 제작
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds)
        return queryFactory
                .from(review)
                .where(eqTags(selectedTagIds))
                .fetch();
    }
    ```
    

- `BooleanExpression`을 활용하여 **태그 개수에 따라 WHERE 쿼리를 동적으로 조절하도록 함**
    
    ```java
    // 모든 태그가 포함된 리뷰면 true
    private BooleanExpression eqTags(List<Integer> selectedTagIds){
        return selectedTagIds!= null && !selectedTagIds.isEmpty() ? Expressions.allOf(selectedTagIds.stream().map(this::isContainsTagId).toArray(BooleanExpression[]::new)) : null;
    }
    
    // 한 태그가 포함된 리뷰면 true
    private BooleanExpression isContainsTagId(Integer selectedTagId) {
        return review.tagIds.contains(selectedTagId);
    }
    ```
    

- 장점
    - join 쿼리를 사용하지 않음 → 쿼리 복잡도 낮음
    - tag 필드가 Collection 타입인 경우도 사용 가능함
- 단점
    - 조회하려는 태그가 많을 경우 WHERE절이 늘어남 → 성능 저하
    - contains는 인덱스를 활용하지 않아 모든 행 검사가 일어남 → 리뷰 수가 많을 경우 성능 크게 저하
- 언제 사용하는게 좋은가?
    - tag 필드가 Collection 타입인 경우 → 인덱스가 없으므로 가장 효율적
    - 

### ✅ 시도 5: join + groupBy + having 활용 → 성공!

- 여러개의 값들을 모두 포함하는 조회를 할때 join과, groupBy, having을 사용하면 문제를 손쉽게 해결할 수 있다.
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds)
        return queryFactory
                .from(review)
                .join(tag).on(tag.review.id.eq(review.id))
                .where(tag.tagId.in(selectedTagIds))
                .groupBy(review.id)
                .having(tag.tagId.count().eq(selectedTagIds.size()))
                .fetch();
    }
    ```
    
- 쿼리 동작 방식
    1. join을 이용하여 review테이블과 tag테이블을 연결
    2. where문을 이용하여 요청한 태그가 하나라도 포함된 review만 1차 필터링
    3. groupBy로 tag를 그룹화 후 having으로 요청한 총 태그의 개수가 같은 review만 조회

- 장점
    - join을 사용하므로 조회하려는 태그가 많아져도 성능 저하되지 않음
    - 인덱스를 사용하여 조회 가능 → 리뷰 수가 많아져도 성능 저하되지 않음
- 단점
    - join을 사용하므로 불필요한 연산 가능성 있음 → review와 tag에 인덱스가 존재하므로 문제없음
    - tag 필드가 **Collection 타입**인 경우 QueryDSL에서 join이 불가능하므로 사용 불가
        
        → 이 경우, QueryDSL 대신 네이티브 SQL을 활용해야 함
        

### ❓동적 쿼리와 join+groupBy+having 성능 비교 (시도 4 vs 시도 5)

- 거의 모든 면에서 join+groupBy+having의 성능이 더 좋음
- tag 필드가 Collection 타입인 경우 동적 쿼리의 성능이 더 좋음

# 💎결론

- **QueryDSL을 활용하여 여러개의 태그를 포함하는 게시물 조회하는 함수를 제작하였다.**
- 제작 방법은 2가지가 있다.
    1. 동적 쿼리를 사용하는 방법
    2. join + groupBy + having을 사용하는 방법
- 성능은 거의 모든 면에서 두번째 방법이 좋았다. 다만 Collection 타입의 필드를 사용할 경우에는 첫번째 방법을 사용하는것이 좋다.
</details>



<details>
<summary>DTO 형변환시의 코드 가독성 문제 해결</summary>
<br>

# 🤔문제 발생

- Tuple을 사용하여 DTO를 변환하는 과정에서 코드가 복잡해지고, 가독성이 떨어지며 유지보수에 어려움이 발생했다.

- **문제의 코드**
    - 수동으로 DTO에 매핑하는 구조 → **코드 복잡, 가독성 저하**
    
    ```jsx
    public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
        List<Tuple> results = queryFactory
                    .from(review)
                .select(review, tag.tagId, reviewImage.id, user)
                .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
                .leftJoin(review.user).fetchJoin()
                .leftJoin(tag).on(review.id.eq(tag.review.id))
                .where(review.id.eq(reviewId))
                .fetch();
    
        Map<Long, ShowReviewResponse> reviewMap = new HashMap<>();
        Long reviewId = null;
        for (Tuple tuple : results) {
            Review reviewEntity = tuple.get(review);
            Integer tagId = tuple.get(tag.tagId);
            UUID reviewImageId = tuple.get(reviewImage.id);
            User userEntity = tuple.get(user);
            reviewId = reviewEntity.getId();
    
            ShowReviewResponse res = reviewMap.computeIfAbsent(reviewEntity.getId(), key 
                    -> new ShowReviewResponse(reviewEntity, userEntity));
            if (tagId != null) {
                res.addTagId(tagId);
            }
            if (reviewImageId != null) {
                res.addImageId(reviewImageId);
            }
        }
        return reviewMap.get(reviewId);
    
    }
    ```
    

# ⛏해결 과정

## **✅** 시도 1 : @QueryProjection 사용하기

- @QueryProjection을 활용하여 Q타입 DTO 객체를 자동으로 생성하고, 이를 **select()**에서 바로 사용
- **🛠 리팩토링 결과**
    
    ```java
    public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
        return queryFactory
                .select(new QShowReviewResponse(
                        review,
                        set(reviewImage.id),    
                        set(tag.tagId)
                ))
                .from(review)
                .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
                .leftJoin(review.user).fetchJoin()
                .leftJoin(tag).on(review.id.eq(tag.review.id))
                .where(review.id.eq(reviewId))
                .groupBy(review.id, reviewImage.id, tag.tagId)
                .fetchOne();
    }
    ```
    

- **문제 발생** : **카테시안 곱 문제가 발생**
    - DISTINCT로는 해결할 수 없음
        - 카테시안 곱에서 발생한 중복 데이터는 해결하지 못한다!
        - left join에 의해 여러 reviewImage와 여러 tag가 하나의 review에 대해 각각 다른 행으로 생성
            
            → reviewImage.id와 tag.tagId는 개별적으로 그룹화되어 중복된 데이터 생성됨
            



## **✅** 시도 2 : QueryDSL의 groupBy().transform() 사용하기

### ❓일반적인 groupBy와 무엇이 다른가?

- **그룹화 시점이 다르다!**
    - 일반적인 groupBy는 그룹화 로직을 **DB에서 수행**
    - groupBy().transform()은 그룹화 로직을 **메모리에서 수행**
        
        → **카테시안 곱 문제를** 간단하게 해결할 수 있음
        

### ❓카테시안 곱 문제를 어떻게 해결할까?

- 메모리에서 그룹화를 수행하기 때문에 복잡한 DB 쿼리 대신 java 라이브러리를 이용할 수 있음
    
    → java의 set() 함수 이용하여 중복 제거 후 DTO로 변환 가능
    

### ❓사용시 성능 저하 문제는 없을까?

- **그룹화할 데이터의 양이 적은 경우에만 사용해야 한다!**
    - 그룹화 로직이 메모리에서 처리되므로 데이터를 한 번에 메모리에 로드해야 함
        
        → 데이터 양이 많으면 CPU와 메모리에 부담을 줄 수 있음
        
    - **이번 문제의 경우..**
        - 함수 호출시 메모리에 로드되는 최대 행 개수가 25개(카테시안 곱으로 인한 중복 데이터 포함)로, 데이터 양이 적어 성능에 큰 영향 없음
        



## **🛠** 최종 리팩토링 결과

```jsx
public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
    return queryFactory
            .from(review)
            .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
            .leftJoin(review.user).fetchJoin()
            .leftJoin(tag).on(review.id.eq(tag.review.id))
            .where(review.id.eq(reviewId))
            .transform(
                    groupBy(review.id).as(
                            new QShowReviewResponse(
                                    review,
                                    set(reviewImage.id),    // 카테시안 곱 문제 방지를 위해 set 사용
                                    set(tag.tagId)          // 카테시안 곱 문제 방지를 위해 set 사용
                            )
                    )
            )
            .get(reviewId);
}
```

# 💎결론

- **QueryDSL의 groupBy().transform()**을 사용하여 DTO로 변환함으로써 가독성을 높이고, 카테시안 곱 문제도 해결할 수 있었다.
</details>



<details>
<summary>동적 쿼리 조회 문제 해결</summary>
<br>

# 🤔문제 발생

- 특정 조건에 맞는 리뷰만 조회하는 필터링 조회 기능을 제작해야 했고, **Native Query**로 작성함
    - 문제의 난잡한 코드..
        
        ```bash
        public interface ReviewRepository extends JpaRepository<Review, Long> {
        
            @Query(value = "SELECT r.id FROM review r " +
                            "WHERE (:currentRating IS NULL OR r.rating < :currentRating) " +
                            "AND r.created_at < :createdAt " +
                            "ORDER BY " +
                            "CASE WHEN :sortMethod = 'HIGH_RATING' THEN r.rating END DESC, " +
                            "CASE WHEN :sortMethod = 'NEW' THEN r.created_at END DESC, " +
                            "LIMIT :pageSize OFFSET :offset", 
                    nativeQuery = true)
            List<Long> findReviewIdsByFilters(
                @Param("currentRating") Double currentRating, 
                @Param("createdAt") LocalDateTime createdAt, 
                @Param("sortMethod") String sortMethod, 
                @Param("pageSize") int pageSize, 
                @Param("offset") int offset
            );
        }
        ```
        

- 문제 1: 조회 조건이 다양하여 쿼리문이 길어짐
    
    **→ 가독성, 유지보수성이 떨어지는 문제 발생**.
    
- 문제 2: 특정 조건을 제외하고 호출해야 할 경우, 그 조건을 제외한 함수를 따로 만들어야 함
    
    **→ 코드 재사용성이 어려워지는 문제 발생**
    

# 🔍원인 분석

### 조회 필터링 종류

- 정렬 방식 : 최신순, 별점 높은 순
- 특정 별점 이하의 리뷰만 조회 **(정렬방식이 별점 높은 순일 경우만 사용)**
- 리턴할 리뷰 개수 지정 가능
- 특정 timestamp 이후의 리뷰만 조회

### 조회 필터링 특징

- 정렬 방식에 따라 필요한 조건이 달라진다 → **조건을 동적으로 처리할 방법이 필요**
- 필터링 종류가 다양하다. → **함수를 쪼개어 가독성을 높여야 함**

# ⛏해결 과정

## 💡 QueryDSL 사용하기

- **QueryDSL의 특징**
    
    QueryDSL은 사용자 요청에 따라 동적으로 쿼리를 생성할 수 있는 기능을 제공. 
    
    이를 통해 복잡한 쿼리문을 효율적으로 관리하고 코드 리팩토링을 진행할 수 있음.
    

    

- **ORDER BY 쿼리를 동적으로 만들기**
    - **QueryDSL의 OrderSpecifier 타입**을 사용하여,
    요청된 정렬 방식에 맞춰 동적으로 ORDER BY 쿼리를 구성.
        
        ```java
        // 최신순 or 별점 높은순으로 정렬
        private OrderSpecifier[] createOrderSpecifier(String sortMethod){
            List<OrderSpecifier> orderSpecifiers = new ArrayList<>();
            switch (sortMethod) {
                case "NEW" :
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.createdAt));
                    return orderSpecifiers.toArray(new OrderSpecifier[orderSpecifiers.size()]);
                case "HIGH_RATING" :
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.rating));
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.createdAt));
                    return orderSpecifiers.toArray(new OrderSpecifier[orderSpecifiers.size()]);
                default:
                    throw new ReviewInvalidSortError(ErrorCode.REVIEW_INVALID_SORT_ERROR);
            }
        }
        ```
        
    - 위 함수를 사용하여 **가독성과 코드 재사용성을 높인 모습**
        
        ```java
        public List<Long> findReviewIdsByFilters(String sortMethod) {
            OrderSpecifier[] orderSpecifiers = createOrderSpecifier(sortMethod);
            return queryFactory
                    // 코드생략.. 
                    .orderBy(orderSpecifiers)
                    // 코드 생략..
            }
        ```
        

- WHERE 쿼리를 동적으로 만들기
    - **QueryDSL의 BooleanExpression 타입**을 사용하여,
    요청된 정렬 방식에 맞춰 동적으로 WHERE 쿼리를 구성.
        
        ```java
        // 특정 별점 이하의 리뷰만 조회
        // 리뷰의 별점 <= 주어진 별점값 이면 true
        private BooleanExpression isLowerThenRating(Integer currentRating) {
            return currentRating != null ? review.rating.loe(currentRating) : null;
        }
        
        // 특정 timestamp 이후의 리뷰만 조회
        // 리뷰의 생성시간 <= 주어진 생성시간 이면 true
        private BooleanExpression isBeforeCreatedAt(LocalDateTime createdAt) {
            return createdAt != null ? review.createdAt.loe(createdAt) : null;
        }
        ```
        
    - 위 함수를 사용하여 **가독성과 코드 재사용성을 높인 모습**
        
        ```java
        public List<Long> findReviewIdsByFilters(String sortMethod, Integer currentRating, LocalDateTime createdAt, Pageable pageable) {
            return queryFactory
                                // 코드 생략..
                    .where(
                            isLowerThenRating(currentRating),
                            isBeforeCreatedAt(createdAt)
                    )
                                // 코드 생략..
            }
        ```
        



## 📌 **개선된 코드**

- 리팩토링 전

```java
public interface ReviewRepository extends JpaRepository<Review, Long> {
    @Query(value = "SELECT r.id FROM review r " +
                    "WHERE (:currentRating IS NULL OR r.rating < :currentRating) " +
                    "AND r.created_at < :createdAt " +
                    "ORDER BY " +
                    "CASE WHEN :sortMethod = 'HIGH_RATING' THEN r.rating END DESC, " +
                    "CASE WHEN :sortMethod = 'NEW' THEN r.created_at END DESC, " +
                    "LIMIT :pageSize OFFSET :offset", 
            nativeQuery = true)
    List<Long> findReviewIdsByFilters(
        @Param("currentRating") Double currentRating, 
        @Param("createdAt") LocalDateTime createdAt, 
        @Param("sortMethod") String sortMethod, 
        @Param("pageSize") int pageSize, 
        @Param("offset") int offset
    );
}
```

- 리팩토링 후

```java
public List<Long> findReviewIdsByFilters(String sortMethod, Integer currentRating, LocalDateTime createdAt, Pageable pageable) {
    OrderSpecifier[] orderSpecifiers = createOrderSpecifier(sortMethod);
    return queryFactory
            .select(review.id)
            .from(review)
            .where(
                    isLowerThenRating(currentRating),
                    isBeforeCreatedAt(createdAt)
            )
            .orderBy(orderSpecifiers)
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .fetch();
    }
```

# 💎결론

- QueryDSL을 활용하여 동적인 쿼리 생성을 유연하게 처리함으로써, **가독성, 유지보수성, 코드 재사용성이** 개선되었다.
</details>



<details>
<summary>테스트 코드 작성해야 할까?</summary>
<br>

# 🤔문제 발생

- **테스트 코드 작성의 필요성을 느끼지 못함**
    - **postman으로도 충분하다!**
        - postman을 통해 api 호출해보면서 테스트를 진행할 수 있다고 생각
        - 사전에 예외 처리와 로그를 작성하면 버그가 났을때 충분히 해결이 가능하다고 생각

# ⛏해결 과정

## Postman만으로는 부족한 이유

- **API가 많아질수록 테스트에 시간과 노력이 많이 든다**
    - 모든 예외를 적어놓고, 코드 수정 시 해당 예외들을 일일이 실행하여 테스트해야 함.
        - ex) "리뷰 등록" API의 service 계층 로직을 수정하면 그에 대한 모든 예외들을 실행하여 오류를 검사해야 함.
        
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_6-1.png">
        
        - **문제 발생** : 만약 리뷰 엔티티의 "태그" 필드를 수정하면, 그 엔티티를 사용하는 모든 API와 예외들을 하나하나 실행해야 함. 이 작업은 시간이 많이 걸리고 귀찮음

## **테스트코드를 만들면서 느낀 테스트 코드의 필요성**

- **기존 로직을 수정할 때** 발생하는 새로운 버그를 쉽게 추적할 수 있다!
    - 예를 들어, A개발자가 만든 로직을 B개발자가 수정할때 중요 로직을 실수로 빠뜨려 예상하지 못한 버그가 발생
        - A개발자가 테스트 코드를 작성해놓았다면, B개발자는 테스트 코드를 통해 쉽게 문제를 찾을 수 있음
- 테스트 코드가 **문서 역할**을 함
    - 테스트 코드는 코드 자체가 문서가 되어, 타 개발자가 로직의 흐름을 한눈에 파악할 수 있게 해줌.

→ 결국 **테스트코드는 내 코드를 수정할 미래의 나 자신 혹은 동료개발자를 위해 필요**

## 프로젝트를 진행하며 느낀 테스트 코드의 결함

- **내 코드의 결함은 테스트 코드로 잡아낼 수 없다!**
    - 내가 겪은 문제 : 통합 테스트를 거친 뒤 API를 완성했지만, 내가 발견하지 못한 버그가 동료 개발자에 의해 발견됨
        
        → 내가 만드는 테스트코드는 **내가 인지하는 범위 내에서만 테스트하기 때문에** 내가 인지하지 못하는 버그는 잡아내지 못한다. 
        
- 해결 : 동료 개발자도 내 로직의 테스트를 해주어야 함 → QA 역할 필요

# 💎결론

- **테스트코드는 내 코드를 수정할 미래의 나 자신 혹은 동료개발자를 위해 필요하다**
- **Postman보다 테스트코드를 작성하는것이 장기적으로는 효율적이다.**
- **테스트 코드는 문서 역할도 하여** 동료 개발자에게 유용하다.
- 내가 만든 테스트코드만으로는 에러를 커버할 수 없으므로 **동료 개발자의 QA를** 통해 보완해야 한다.
</details>

<details>
<summary>어떤 로직이 테스트 코드가 필요할까?</summary>
<br>

# 🤔문제 발생

- 기능 구축 후 통합 테스트 코드 작성을 시도했지만, 모든 부분을 테스트하기엔 시간이 부족해 테스트가 필요한 부분만 추려야 했음. 하지만 어떤 기준으로 추려야 할지 고민

# ⛏해결 과정

## ❓어떤 로직이 테스트가 필요할까?

- 가성비 있는 로직 : “**테스트코드를 짜는 시간 < 버그를 찾는 시간**” 인 로직
- 테스트가 꼭 필요한 로직 : 심각한 오류를 방지해야 하는 로직

## ❓**가성비 있는 로직의 특징?**

- **문서화가 필요한 로직**
    - 로직이 복잡한 경우
    - 통상적인 로직 규칙과는 다르게 구현한 경우
        - 기존에 널리 사용되는 규칙이나 패턴을 벗어난 구현은 새로운 개발자가 이해하기 어렵다. 이러한 로직을 문서화하면 향후 수정 시 실수를 줄일 수 있다.
        - ex) Util 함수
    - 동료 개발자가 내 코드를 수정할 때 조심해야 하는 부분이 존재하는 경우
        - 예를 들어,
            
            ```jsx
            public List<ShowReviewResponse> findUserReviews(String username, ShowUserReviewRequest request) {
                User user = userRepository.findByUsername(username).orElseThrow(() ->{
                    throw new UserNotFoundException(username, ErrorCode.USER_NOT_FOUND_ERROR);
                });
                Pageable pageable = PageRequest.of(0, request.getLimit());
                return reviewRepository.searchByUser(user, request.getTimestamp(), pageable);
            }
            ```
            
            위 함수에서 `PageRequest.*of*(0, request.getLimit())` 의 첫번째 매개변수가 반드시 0이어야 한다. 만약 동료 개발자가 모르고 0이 아닌 다른 값을 넣어버리면 오류는 나지 않지만 잘못된 값이 반환돤다. 
            
            → **예외가 발생하지 않는 버그이기 때문에 문서화 필요**
            

## ❓테스트가 꼭 필요한 로직의 특징?

- **본인이 알지 못하는 심각한 오류를 방지할 수 있는 로직**
    - 내가 만드는 테스트코드는 **내가 인지하는 범위 내에서만 테스트하기 때문에** 내가 인지하지 못하는 버그는 잡아내지 못한다.
    - **동료 개발자**가 해당 로직에 대한 테스트 코드를 작성한다면, 내가 미처 발견하지 못한 오류를 찾을 수 있다.
    - 심각한 오류 예시 : 저장/수정/삭제가 들어간 로직

# 💎결론

- 테스트 코드가 필요한 부분은 두가지다.
    - **문서화해야 할 정도로 복잡한 로직**
        
        → 이 경우, 로직을 짠 본인이 테스트 코드를 작성해야 한다.
        
    - **심각한 오류가 발생할 가능성이 있는 로직**
        
        → 이 경우, 본인이 아닌 동료 개발자가 테스트 코드를 작성해야 한다.
</details>


<details>
<summary>Static 메소드 mocking 문제 해결</summary>
<br>

# 🤔문제 발생

### static 메소드를 mocking 시도했지만 실패함

- **상황**
    - ImageUtil.saveImage 실행하기에는 추가 세팅이 많이 요구되어 mocking이 필요했음
    
    ```java
    @Service
    public class ReviewImageService {
        @Transactional
        public void addReviewImage(String username, Long reviewId, MultipartFile multipartFile) {
            // 코드 생략 ...
            ImageUtil.saveImage(ImageUtil.REVIEW_IMAGE_PATH, newImageId.toString(), multipartFile);
            // 코드 생략 ...
        }
    }
    ```
    
    - 아래의 public static void인 saveImage 메소드 mock필요
        
        ```java
        public class ImageUtil {
            public static void saveImage(String path, String imageId, MultipartFile file) {
                        // 코드 생략 ...
            }
            }
        ```
        

- **문제**
    - 아래와 같은 방법으로 mocking을 시도
    
    ```java
    public class AddReviewImageTest {
        @MockitoBean
        ImageUtil imageUtil;
        @Autowired
        ReviewImageService reviewImageService;
        
        @Test
        @DisplayName("리뷰 이미지 파일 저장 성공")
        public void addReviewImageSuccess() {
            // when
            reviewImageService.addReviewImage(username, reviewId, imageFile);
    
            // then
                    // 코드 생략 ...
        }
    }
    ```
    
    - 테스트 실행 결과, mock처리가 되지 않은 채 동작

# 🔍원인 분석

- Static 메소드는 Bean으로 등록되지 않기 때문에 @MockitoBean을 사용한 mocking이 불가능하다.

# ⛏해결 과정

## ✅과정 1 : MockedStatic 사용하기

- MockedStatic을 사용하여 정적 메소드를 mock하는 방법을 발견
    
    (참고 : [https://www.testim.io/blog/mocking-static-methods-mockito/](https://www.testim.io/blog/mocking-static-methods-mockito/))
    

<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_8-1.png">

- 구현 코드
    
    ```java
    public class AddReviewImageTest {
        @Autowired
        ReviewImageService reviewImageService;
        
        @Test
        @DisplayName("리뷰 이미지 파일 저장 성공")
        public void addReviewImageSuccess() {
            //given
            try (MockedStatic<ImageUtil> imageUtil = mockStatic(ImageUtil.class)) {
                imageUtil.when(()-> ImageUtil.saveImage(anyString(), anyString(), any(MultipartFile.class))).thenReturn(null);
                
                // when
                reviewImageService.addReviewImage(username, reviewId, imageFile);
        
                // then
                            // 코드 생략 .. 
            }
        }
    }
    ```
    
    - try문으로 감싸 try문이 끝나면 mock 객체를 해제하도록 함. 그렇지 않으면 다른 테스트 함수에서도 mock객체를 사용하게 됨
    
        
    
- **문제 발생**

<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_8-2.png">

위 방법은 리턴 형식이 void가 아닌 경우만 가능했음



## ✅과정 2 : thenReturn 대신 thenAnswer 사용하기

- 위의 방법을 사용하면서 void 메소드를 mock하기 위해 thenReturn 대신 thenAnswer를 활용

```java
public class AddReviewImageTest {
    @MockitoBean
    ImageUtil imageUtil;
    @Autowired
    ReviewImageService reviewImageService;
    
    @Test
    @DisplayName("리뷰 이미지 파일 저장 성공")
    public void addReviewImageSuccess() {
        //given
        try (MockedStatic<ImageUtil> imageUtil = mockStatic(ImageUtil.class)) {
            imageUtil.when(()-> ImageUtil.saveImage(anyString(), anyString(), any(MultipartFile.class))).thenAnswer(i -> {
                System.out.println("모킹된 ImageUtil.save() 호출");
                return null;
            });
            
            // when
            reviewImageService.addReviewImage(username, reviewId, imageFile);
    
            // then
                        // 코드 생략 .. 
        }
    }
}
```

(참고 : [https://unluckyjung.github.io/testcode/2021/12/20/Mockito-StaticMethod-Mocking/](https://unluckyjung.github.io/testcode/2021/12/20/Mockito-StaticMethod-Mocking/))

# 💎결론

- static 메소드 mock처리시 MockedStatic을 사용하고, static void 메소드인 경우 thenAnswer를 사용하여 처리한다.
</details>






</details>

## 🔗 프로젝트 문서
* [노션](https://www.notion.so/brewscape-1aa5086f3cd981d8bfc7d1268f412eef)
* [포스트맨](https://www.postman.com/cafelog/workspace/brewscape/collection/29229206-35a74e5f-6a03-4cef-a42b-a8f715c49f6a?action=share&creator=29229206)
* [피그마](https://www.figma.com/design/oKBqtFRDw3inqtQKFvjAtX/%5B2025-%ED%8C%80-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%5D-%EC%BB%A4%ED%94%BC-%EA%B8%B0%EB%A1%9D_v2?node-id=0-1&t=imFTzWrwa0Xzungi-1)
